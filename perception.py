"""
perception.py

Code for modelling option and outcome perceptions.
"""

from base_types import Certainty, Valence, Salience

class Percept:
  """
  Base class for all percepts, modelling general player perceptions of options
  & outcomes (relative to player goals). A percept applies to a specific goal,
  and is generated by a specific outcome of a specific option at a specific
  choice. The 'valence' may be "negative", "neutral", or "positive" or may be a
  number between -1 and 1.
  """
  def __init__(
    self,
    goal=None,
    choice=None,
    option=None,
    outcome=None,
    valence=Valence.neutral,
    salience=Salience.explicit,
  ):
    """
    goal:
      The goal name that this percept applies to.
    choice:
      The name of the choice object that this percept is generated by.
    option:
      The option name at that choice, or None to specify a general percept of
      the choice.
    outcome:
      The outcome that this percept is generated by, or None to specify a
      general percept of an option.
    valence:
      The positive or negative alignment of this percept. Should be "positive",
      "negative", or "neutral", or else a number between -1 and 1.
    salience:
      The apparent importance/relevance of this percept.
    """
    self.goal = goal
    self.choice = choice
    self.option = option if option != "" else None
    self.outcome = outcome if outcome != "" else None
    if self.outcome and not self.option:
      raise ValueError(
        "Can't specify an outcome without specifying an option.\n"
        "(While creating Percept for goal '{}' at choice '{}')".format(
          goal,
          choice
        )
      )
    self.valence = Valence(valence)
    self.salience = Salience(salience)

  def __str__(self):
    return str(self.pack())

  def __eq__(self, other):
    if not isinstance(other, Percept):
      return False
    return (
      self.goal == other.goal
  and self.choice == other.choice
  and self.option == other.option
  and self.outcome == other.outcome
  and self.valence == other.valence
  and self.salience == other.salience
    )

  def __hash__(self):
    h = 3 * hash(self.goal)
    h ^= hash(self.choice)
    h += hash(self.option)
    h ^= hash(self.outcome)
    h += hash(self.valence)
    h ^= hash(self.salience)
    return h

  def pack(self):
    """
    Returns a simple object suitable for conversion to JSON.

    Example:

    ```
    Percept(
      "avoid_conflict",
      "run_or_fight",
      "run",
      None,
      0.8,
      1.0
    )
    ```
    {
      "type": "Percept",
      "goal": "avoid_conflict",
      "choice": "run_or_fight",
      "option": "run",
      "outcome": "",
      "valence": 0.8,
      "salience": "explicit"
    }
    ```
    """
    return {
      "type": "Percept",
      "goal": self.goal,
      "choice": self.choice,
      "option": self.option or "",
      "outcome": self.outcome or "",
      "valence": self.valence.regular_form(),
      "salience": self.salience.regular_form()
    }

  def unpack(obj):
    """
    The inverse of `pack`; creates a Percept from a simple object. This method
    handles unpacking for subtypes Prospective and Retrospective as well.
    """
    if obj["type"] == "Percept":
      return Percept(
        obj["goal"],
        obj["choice"],
        obj["option"],
        obj["outcome"],
        Valence(obj["valence"]),
        Salience(obj["salience"]),
      )
    elif obj["type"] == "Prospective":
      return Prospective(
        obj["goal"],
        obj["choice"],
        obj["option"],
        obj["outcome"],
        Valence(obj["valence"]),
        Salience(obj["salience"]),
        certainty=Certainty(obj["certainty"])
      )
    elif obj["type"] == "Retrospective":
      return Retrospective(
        obj["goal"],
        obj["choice"],
        obj["option"],
        obj["outcome"],
        Valence(obj["valence"]),
        Salience(obj["salience"]),
        prospective=Prospective.unpack(obj["prospective"])
      )

  def utility(self):
    """
    Computes the perceived "utility" of this percept. Note: try not to rely on
    this method, as it doesn't model human decision making very well at all.
    """
    return self.valence * self.salience


class Prospective(Percept):
  """
  A percept generated before making a decision.
  """
  enables = None
  threatens = None
  advances = None
  hinders = None
  def __init__(self, *args, certainty=Certainty.certain, **kwargs):
    """
    In addition to arguments used for creating a general Percept,
    ProspectivePercepts accept a "certainty" argument, which should be either a
    Certainty object (see base_types.py) or a probability between 0 and 1. Note
    that this must be passed as a keyword argument!
    """
    super().__init__(*args, **kwargs)
    self.certainty=Certainty(certainty)

  def __eq__(self, other):
    if not isinstance(other, Prospective):
      return False
    return (
      super().__eq__(other)
  and self.certainty == other.certainty
    )

  def __str__(self):
    return str(self.pack())

  def __hash__(self):
    h = super().__hash__()
    h ^= 3 * hash(self.certainty)
    return h

  def pack(self):
    """
    Packs into a simple object; suitable for conversion to JSON.

    Example:

    ```
    Prospective(
      "avoid_conflict",
      "run_or_fight",
      "run",
      "get_away",
      0.8,
      "explicit",
      certainty="even"
    )
    ```
    {
      "type": "Prospective",
      "goal": "avoid_conflict",
      "choice": "run_or_fight",
      "option": "run",
      "outcome": "get_away",
      "valence": 0.8,
      "salience": "explicit",
      "certainty": "even"
    }
    ```
    """
    result = super().pack()
    result["type"] = "Prospective"
    result["certainty"] = self.certainty.regular_form()
    return result

  # unpacking handled by Percept.unpack

  def utility(self):
    """
    Override to include certainty in the calculation.
    """
    return self.valence * self.salience * self.certainty

class Enables(Prospective):
  """
  "Enables" is a prospective percept indicating that a specific option has the
  possibility of advancing a goal.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      certainty=Certainty.even,
      valence=Valence.good,
      **kwargs
    )

class Threatens(Prospective):
  """
  "Threatens" is the opposite of "enables": It indicates the possibility that a
  goal will be hindered by an option.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      certainty=Certainty.even,
      valence=Valence.bad,
      **kwargs
    )

class Advances(Prospective):
  """
  "Advances" indicates that choosing the given option should definitely advance
  the specified goal.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      certainty=Certainty.certain,
      valence=Valence.good,
      **kwargs
    )

class Hinders(Prospective):
  """
  "Hinders" indicates that choosing the given option should definitely hinder
  the specified goal.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      certainty=Certainty.certain,
      valence=Valence.bad,
      **kwargs
    )


class Retrospective(Percept):
  """
  A percept generated after observing some outcome(s) of a chosen option.
  """
  def __init__(
    self,
    *args,
    prospective=None,
    expected_valence=Valence.neutral,
    expected_certainty=Certainty.likely,
    expected_salience=Salience.explicit,
    **kwargs
  ):
    """
    prospective:
      A Prospective percept object that anchors this retrospective impression.
      May be left out if expected_valence, expected_certainty, and
      expected_salience are given instead. Must be specified if the anchoring
      Prospective impression has a different outcome than the Retrospective
      percept.
    expected_valence/certainty/salience:
      If no prospective percept is given, these can be given instead and will
      be used to define one which has the same goal, choice, option, and
      outcome as the Retrospective percept being created. These are ignored if
      a prospective impression is given.
    """
    super().__init__(*args, **kwargs)
    if prospective:
      if prospective.goal != self.goal:
        raise ValueError(
          "Prospective for a Retrospective percept has different goal."
        )
      if prospective.choice != self.choice:
        raise ValueError(
          "Prospective for a Retrospective percept has different choice."
        )
      if prospective.option != self.option:
        raise ValueError(
          "Prospective for a Retrospective percept has different option."
        )
      # Note: Outcomes *are* allowed to differ
      self.prospective = prospective
    else:
      self.prospective = Prospective(
        goal=self.goal,
        choice=self.choice,
        option=self.option,
        outcome=self.outcome,
        valence=expected_valence,
        certainty=expected_certainty,
        salience=expected_salience,
      )

  def __str__(self):
    return str(self.pack())

  def __eq__(self, other):
    if not isinstance(other, Retrospective):
      return False
    return (
      super().__eq__(other)
  and self.prospective == other.prospective
    )

  def __hash__(self):
    h = super().__hash__()
    h += 5 * hash(self.prospective)
    return h

  def pack(self):
    """
    Packs into a simple object; suitable for conversion to JSON.

    Example:

    ```
    Retrospective(
      "avoid_conflict",
      "run_or_fight",
      "run",
      "get_caught",
      -0.95,
      1.0,
      expected_valence="awful",
      expected_certainty=0.5,
      expected_salience=1.0
    )
    ```
    {
      "type": "Retrospective",
      "goal": "avoid_conflict",
      "choice": "run_or_fight",
      "option": "run",
      "outcome": "get_caught",
      "valence": "awful",
      "salience": "explicit",
      "prospective": {
        "type": "Prospective",
        "goal": "avoid_conflict",
        "choice": "run_or_fight",
        "option": "run",
        "outcome": "get_caught",
        "valence": "awful",
        "salience": "explicit",
        "certainty": "even"
      }
    }
    ```
    """
    result = super().pack()
    result["type"] = "Retrospective"
    result["prospective"] = self.prospective.pack()
    return result

  # unpacking handled by Percept.unpack

  def merge_retrospective_impressions(ilist):
    """
    Takes a list of retrospective impressions for the same goal/choice/option
    and merges them into a single abstract impression of that goal/choice/
    option, which includes an abstract prospective impression as well. The
    outcome referenced will be explicit if they all share an outcome, or the
    resulting percept will be at the option level if they do not.
    """
    shared_goal = ilist[0].goal
    shared_choice = ilist[0].choice
    shared_option = ilist[0].option
    shared_outcome = ilist[0].outcome

    if any(impr.goal != shared_goal for impr in ilist[1:]):
      raise ValueError(
        "Retrospective impressions in merge don't all share goal '{}'.".format(
          shared_goal
        )
      )
    if any(impr.choice != shared_choice for impr in ilist[1:]):
      raise ValueError(
        "Retrospective impressions in merge don't share choice '{}'.".format(
          shared_choice
        )
      )
    if any(impr.option != shared_option for impr in ilist[1:]):
      raise ValueError(
        "Retrospective impressions in merge don't share option '{}'.".format(
          shared_option
        )
      )
    if any(impr.outcome != shared_outcome for impr in ilist[1:]):
      shared_outcome = None

    pr_certainties = [impr.prospective.certainty for impr in ilist]
    pr_salineces = [impr.prospective.salience for impr in ilist]
    pr_utilities = [impr.prospective.utility() for impr in ilist]

    # half-way between minimum and average
    combined_certianty = (
      min(pr_certainties)
    + sum(pr_certainties) / len(ilist)
    ) / 2

    combined_salience = max(pr_salineces)

    # TODO: Different methods for combining valences?
    combined_valence = sum(pr_utilities) / len(ilist)

    abstract_prospective = Prospective(
      goal=shared_goal,
      choice=shared_choice,
      option=shared_option,
      outcome=shared_outcome,
      certainty=combined_certianty,
      salience=combined_salience,
      valence=combined_valence
    )

    rt_saliences = [impr.salience for impr in ilist]

    # TODO: better than utility here?
    rt_utilities = [impr.utility() for impr in ilist]

    combined_salience = max(rt_saliences)
    combined_valence = sum(rt_utilities) / len(ilist)

    return Retrospective(
      goal=shared_goal,
      choice=shared_choice,
      option=shared_option,
      outcome=shared_outcome,
      salience = combined_salience,
      valence = combined_valence,
      prospective = abstract_prospective
    )


class Miserable(Retrospective):
  """
  The perception that an outcome was bad, and that that was known ahead of time.
  """
  # TODO: How to represent difference between choosing a known bad outcome and
  # feeling forced vs. feeling rebellious?
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.bad,
      expected_valence=Valence.bad,
      expected_certainty=Certainty.certain,
      **kwargs
    )

class Mistake(Retrospective):
  """
  The perception that an outcome was bad, but wasn't really foreseeable.
  """
  # TODO: how to model the knowledge/fairness involved/required.
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.bad,
      expected_valence=Valence.okay,
      expected_certainty=Certainty.likely,
      **kwargs
    )

class UnexpectedFailure(Retrospective):
  """
  A decision that seemed good but turned out to be awful.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.bad,
      expected_valence=Valence.good,
      expected_certainty=Certainty.certain,
      **kwargs
    )

class Unfortunate(Retrospective):
  """
  A decision that seemed neutral but turned out bad.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.bad,
      expected_valence=Valence.neutral,
      expected_certainty=Certainty.even,
      **kwargs
    )

class Fortunate(Retrospective):
  """
  A decision that seemed neutral but turned out well.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.good,
      expected_valence=Valence.neutral,
      expected_certainty=Certainty.even,
      **kwargs
    )

class Relief(Retrospective):
  """
  A decision that seemed bad but turned out okay.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.okay,
      expected_valence=Valence.bad,
      expected_certainty=Certainty.likely,
      **kwargs
    )

class Disappointment(Retrospective):
  """
  A decision that seemed okay but turned not great.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.unpleasant,
      expected_valence=Valence.okay,
      expected_certainty=Certainty.even,
      **kwargs
    )

class GoodDecision(Retrospective):
  """
  A decision that seemed good and turned out that way.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.good,
      expected_valence=Valence.good,
      expected_certainty=Certainty.even,
      **kwargs
    )

class ExpectedSuccess(Retrospective):
  """
  A decision that was surely good and turned out that way.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.good,
      expected_valence=Valence.good,
      expected_certainty=Certainty.certain,
      **kwargs
    )

class UnexpectedSuccess(Retrospective):
  """
  An outcome that seemed likely unpleasant but turned out well in the end.
  """
  def __init__(self, *args, **kwargs):
    super().__init__(
      *args,
      valence=Valence.good,
      expected_valence=Valence.unpleasant,
      expected_certainty=Certainty.likely,
      **kwargs
    )
